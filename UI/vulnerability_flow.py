#!/usr/bin/env python3
"""
Vulnerability Processing Module for CyberFlow UI
Takes port scanner results as input and identifies potential vulnerabilities
"""

import sys
import json
import time
import random
import datetime
from datetime import datetime

# Parse JSON input from Node.js
data_str = sys.argv[1] if len(sys.argv) > 1 else "{}"
data = json.loads(data_str)

# Extract scan results from input
# The input should be the output from cidr_scanner.py
scan_results = data.get("scan_results", {})

class VulnerabilityFlow:
    def __init__(self, scan_results):
        """
        Initialize with scan results
        
        Args:
            scan_results (dict): Dictionary mapping IP addresses to open ports/services
        """
        self.scan_results = scan_results
        self.results = {}
        self.vuln_modules = self.load_vulnerability_modules()
        
    def load_vulnerability_modules(self):
        """Load vulnerability check modules"""
        # Simplified version with key vulnerabilities by service/port
        modules = {
            # Service-based modules
            'http': [
                {
                    'name': 'Apache Struts RCE',
                    'cve': 'CVE-2017-5638',
                    'severity': 'Critical',
                    'description': 'Apache Struts Remote Code Execution vulnerability',
                    'success_indicator': 'Remote Code Execution'
                },
                {
                    'name': 'WordPress Plugin Vulnerability',
                    'cve': 'CVE-2021-24583',
                    'severity': 'High',
                    'description': 'WordPress plugin vulnerable to file upload',
                    'success_indicator': 'WordPress Installation Found'
                }
            ],
            'ssh': [
                {
                    'name': 'SSH Weak Credentials',
                    'cve': 'N/A',
                    'severity': 'Medium',
                    'description': 'SSH server configured with weak password policy',
                    'success_indicator': 'Success'
                }
            ],
            'smb': [
                {
                    'name': 'EternalBlue',
                    'cve': 'CVE-2017-0144',
                    'severity': 'Critical',
                    'description': 'Windows SMB Remote Code Execution Vulnerability',
                    'success_indicator': 'Host is likely VULNERABLE'
                }
            ],
            'ftp': [
                {
                    'name': 'vsftpd Backdoor',
                    'cve': 'CVE-2011-2523',
                    'severity': 'Critical',
                    'description': 'vsftpd 2.3.4 backdoor vulnerability',
                    'success_indicator': 'vsftpd 2.3.4 confirmed'
                }
            ],
            # Port-based modules (fallback)
            'port_22': [
                {
                    'name': 'SSH Weak Credentials',
                    'cve': 'N/A',
                    'severity': 'Medium',
                    'description': 'SSH server configured with weak password policy',
                    'success_indicator': 'Success'
                }
            ],
            'port_80': [
                {
                    'name': 'Web Server Vulnerabilities',
                    'cve': 'Multiple',
                    'severity': 'High',
                    'description': 'Common web server vulnerabilities',
                    'success_indicator': 'Remote Code Execution'
                }
            ],
            'port_445': [
                {
                    'name': 'EternalBlue',
                    'cve': 'CVE-2017-0144',
                    'severity': 'Critical',
                    'description': 'Windows SMB Remote Code Execution Vulnerability',
                    'success_indicator': 'Host is likely VULNERABLE'
                }
            ]
        }
        return modules
    
    def process_scan_results(self):
        """Process results from port scanner."""
        # Initialize results structure
        for ip, ports_data in self.scan_results.items():
            # Convert port data to (port, service) format if needed
            ports = []
            if isinstance(ports_data, list):
                # Handle different formats from port scanner
                if ports_data and isinstance(ports_data[0], dict):
                    # Format: [{"port": 80, "service": "http"}, ...]
                    ports = [(item.get("port"), item.get("service", "unknown")) for item in ports_data]
                elif ports_data and isinstance(ports_data[0], (list, tuple)):
                    # Format: [(80, "http"), ...]
                    ports = ports_data
            
            self.results[ip] = {
                "open_ports": ports,
                "vulnerabilities": [],
                "risk_score": 0
            }
        
        # Process each host
        for ip, data in self.results.items():
            self.check_host_vulnerabilities(ip, data["open_ports"])
            
            # Calculate risk score based on vulnerabilities
            self.calculate_risk_score(ip)
        
        return self.results
    
    def check_host_vulnerabilities(self, ip, open_ports):
        """Check vulnerabilities for a specific host."""
        for port, service in open_ports:
            # Find appropriate vulnerability modules
            modules = []
            
            # Try service-specific modules first
            if service.lower() in self.vuln_modules:
                modules = self.vuln_modules[service.lower()]
            
            # Fall back to port-specific modules
            if not modules and f"port_{port}" in self.vuln_modules:
                modules = self.vuln_modules[f"port_{port}"]
            
            # Skip if no modules found
            if not modules:
                continue
            
            # Run each vulnerability check (simulate for demo)
            for module in modules:
                # Simulate vulnerability check with random outcome
                is_vulnerable = self.simulate_vulnerability_check(ip, port, service, module)
                
                if is_vulnerable:
                    # Create vulnerability entry
                    vuln_data = {
                        "name": module["name"],
                        "cve": module["cve"],
                        "severity": module["severity"],
                        "port": port,
                        "service": service,
                        "description": module["description"],
                        "details": self.generate_vulnerability_details(ip, port, service, module),
                        "remediation": self.generate_remediation_advice(module),
                        "timestamp": datetime.now().isoformat()
                    }
                    
                    self.results[ip]["vulnerabilities"].append(vuln_data)
    
    def simulate_vulnerability_check(self, ip, port, service, module):
        """Simulate a vulnerability check with some randomness."""
        # For demo purposes, use a weighted random check
        # In production, this would be replaced with actual scanning
        severity_weights = {
            "Critical": 0.3,  # 30% chance of being vulnerable
            "High": 0.25,     # 25% chance 
            "Medium": 0.15,   # 15% chance
            "Low": 0.05       # 5% chance
        }
        
        # Higher chance for well-known vulnerable services
        service_weights = {
            "http": 0.1,      # Additional 10% for web servers
            "smb": 0.15,      # Additional 15% for SMB
            "ftp": 0.1,       # Additional 10% for FTP
            "telnet": 0.2     # Additional 20% for telnet
        }
        
        # Base probability from severity
        base_prob = severity_weights.get(module["severity"], 0.1)
        
        # Add service-specific probability
        service_prob = service_weights.get(service.lower(), 0)
        
        # Calculate final probability
        final_prob = min(base_prob + service_prob, 0.8)  # Cap at 80%
        
        # Determine if vulnerable
        return random.random() < final_prob
    
    def generate_vulnerability_details(self, ip, port, service, module):
        """Generate detailed information about the vulnerability."""
        # Create realistic vulnerability details based on the type
        details = []
        
        if "Struts" in module["name"]:
            details.append(f"Apache Struts vulnerable to CVE-2017-5638")
            details.append(f"Content-Type header manipulation allows for OGNL expression injection")
            details.append(f"Confirmed vulnerable URL: http://{ip}:{port}/struts2-showcase/")
        
        elif "WordPress" in module["name"]:
            details.append(f"WordPress version 5.7.2 detected")
            details.append(f"Multiple vulnerable plugins identified:")
            details.append(f"- Contact Form 7 (version 5.4.1)")
            details.append(f"- WooCommerce (version 5.3.0)")
        
        elif "EternalBlue" in module["name"]:
            details.append(f"SMBv1 enabled and responding to requests")
            details.append(f"System appears to be running Windows 7 or Windows Server 2008 R2")
            details.append(f"MS17-010 patch not applied")
        
        elif "SSH" in module["name"]:
            details.append(f"SSH server allows password authentication")
            details.append(f"Weak passwords accepted for user accounts:")
            details.append(f"- admin:password")
            details.append(f"- root:root")
        
        elif "vsftpd" in module["name"]:
            details.append(f"vsftpd version 2.3.4 detected")
            details.append(f"Server vulnerable to backdoor command execution")
            details.append(f"Triggered by specific sequence in username")
        
        else:
            details.append(f"Service {service} on port {port} appears vulnerable")
            details.append(f"Standard attack vectors confirmed successful")
        
        return "\n".join(details)
    
    def generate_remediation_advice(self, module):
        """Generate remediation advice based on vulnerability type."""
        # Provide tailored remediation guidance
        if "Struts" in module["name"]:
            return "Update Apache Struts to version 2.5.13 or later. Apply all security patches."
            
        elif "WordPress" in module["name"]:
            return "Update WordPress core to latest version. Update or remove vulnerable plugins. Implement Web Application Firewall."
            
        elif "EternalBlue" in module["name"]:
            return "Apply Microsoft security patch MS17-010. Disable SMBv1 protocol. Implement proper network segmentation."
            
        elif "SSH" in module["name"]:
            return "Disable password authentication in favor of key-based authentication. Implement account lockout policies."
            
        elif "vsftpd" in module["name"]:
            return "Update vsftpd to latest version. Consider using SFTP instead of FTP for secure file transfers."
            
        else:
            return "Update the affected service to the latest version. Apply all security patches. Follow vendor security recommendations."
    
    def calculate_risk_score(self, ip):
        """Calculate risk score based on vulnerabilities."""
        # Severity multipliers
        severity_scores = {
            "Critical": 10,
            "High": 7,
            "Medium": 4,
            "Low": 1
        }
        
        # Calculate base score from vulnerabilities
        base_score = 0
        for vuln in self.results[ip]["vulnerabilities"]:
            base_score += severity_scores.get(vuln["severity"], 0)
        
        # Adjust score based on number of vulnerabilities
        vuln_count = len(self.results[ip]["vulnerabilities"])
        if vuln_count > 1:
            # Add bonus for multiple vulnerabilities
            base_score += vuln_count * 0.5
        
        # Adjust for critical ports
        critical_ports = [22, 23, 80, 443, 445, 3389, 1433, 3306]
        for port, _ in self.results[ip]["open_ports"]:
            if port in critical_ports:
                base_score += 0.5  # Small bonus for each critical port
        
        # Cap the score at 100
        final_score = min(round(base_score), 100)
        self.results[ip]["risk_score"] = final_score
        
        # Add risk level based on score
        if final_score >= 75:
            self.results[ip]["risk_level"] = "Critical"
        elif final_score >= 50:
            self.results[ip]["risk_level"] = "High"
        elif final_score >= 25:
            self.results[ip]["risk_level"] = "Medium"
        else:
            self.results[ip]["risk_level"] = "Low"
    
    def generate_summary(self):
        """Generate a summary of vulnerability findings."""
        total_hosts = len(self.results)
        vulnerable_hosts = sum(1 for ip, data in self.results.items() if data["vulnerabilities"])
        total_vulnerabilities = sum(len(data["vulnerabilities"]) for ip, data in self.results.items())
        
        severity_counts = {
            "Critical": 0,
            "High": 0,
            "Medium": 0,
            "Low": 0
        }
        
        # Count vulnerabilities by severity
        for ip, data in self.results.items():
            for vuln in data["vulnerabilities"]:
                severity_counts[vuln["severity"]] += 1
        
        # Generate host risk summary
        host_risks = {}
        for ip, data in self.results.items():
            host_risks[ip] = {
                "risk_score": data["risk_score"],
                "risk_level": data.get("risk_level", "Unknown"),
                "vulnerability_count": len(data["vulnerabilities"])
            }
        
        summary = {
            "scan_time": datetime.now().isoformat(),
            "total_hosts": total_hosts,
            "vulnerable_hosts": vulnerable_hosts,
            "total_vulnerabilities": total_vulnerabilities,
            "severity_breakdown": severity_counts,
            "host_risk_summary": host_risks
        }
        
        return summary

# Main execution
try:
    if not scan_results:
        # No scan results or empty data
        result = {
            "status": "error",
            "message": "No scan results provided or invalid format",
            "timestamp": datetime.now().isoformat()
        }
    else:
        # Process the scan results
        vulnerability_scanner = VulnerabilityFlow(scan_results)
        vulnerability_results = vulnerability_scanner.process_scan_results()
        summary = vulnerability_scanner.generate_summary()
        
        result = {
            "status": "success",
            "summary": summary,
            "details": vulnerability_results,
            "timestamp": datetime.now().isoformat()
        }
    
    # Output results as JSON
    print(json.dumps({"message": result}))
    
except Exception as e:
    # Handle any errors
    error_output = {
        "status": "error",
        "message": f"Error processing vulnerability scan: {str(e)}",
        "timestamp": datetime.now().isoformat()
    }
    print(json.dumps({"message": error_output}))
